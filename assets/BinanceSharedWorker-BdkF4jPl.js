let l="";function g(e,o){e.forEach(s=>{const{symbol:t,price:r,openPrice:n}=b(s);if(o[t]){const c=w(o[t].openPrice,r);o[t].price=r,o[t].color=c,n&&(o[t].openPrice=n)}})}function b(e){if("s"in e&&"c"in e)return{symbol:e.s,price:parseFloat(e.c)};if("code"in e&&"trade_price"in e)return{symbol:e.code,price:e.trade_price,openPrice:e.opening_price};throw new Error("Unknown data type")}function w(e,o){let s="#FFFFFF";return e<o?s="#f75467":e>o&&(s="#4386f9"),s}async function p(){if(l.length===0)try{const e=await fetch("https://proxy-server-flax-rho.vercel.app/api/proxy?locale=find"),{country:o}=await e.json();return l=o,o==="US"}catch(e){return console.error("Failed to detect country from IP:",e),!1}else return l==="US"}const d="wss://stream.binance.com:9443/ws/!ticker@arr",u="https://api.binance.com/api/v3",h="https://api.binance.us/api/v3";async function m(){try{const e=await p(),s=await(await fetch(`${e?h:u}/exchangeInfo`)).json();if(!s.symbols)throw new Error("Failed to fetch symbols list");return s.symbols.filter(r=>r.symbol.endsWith("USDT")&&r.status==="TRADING").map(r=>r.symbol)}catch(e){return console.error("Error fetching symbols list:",e),[]}}async function F(e){const s=`${await p()?h:u}/klines?symbol=${e}&interval=1d&limit=2`;try{const r=await(await fetch(s)).json();if(!Array.isArray(r)||r.length<2)throw new Error(`No sufficient data for ${e}`);const n=r.length>=2?r[1][1]:r[0][1],c=r.length>=2?r[1][4]:r[0][4];return{symbol:e,openPrice:n,curPrice:c}}catch(t){return console.error(`Error fetching data for ${e}:`,t),{symbol:e,openPrice:null,curPrice:null}}}async function P(e){const o=await m();if(o.length===0){console.error("No symbols available.");return}console.log(`Fetching open prices for ${o.length} symbols...`),(await Promise.all(o.map(F))).forEach(t=>{let r="#FFFFFF";const n=parseFloat(t.curPrice),c=parseFloat(t.openPrice);c<n?r="#f75467":c>n&&(r="#4386f9"),e[t.symbol]={price:n,color:r,openPrice:c}})}const U=self,a=[],i={};let f=null;P(i);const y=e=>{f=new WebSocket(e??d),f.onmessage=o=>{const s=JSON.parse(o.data),t=Array.from(s).filter(r=>r.s.includes("USDT"));try{g(t,i)}catch(r){a.forEach(n=>{n.postMessage(`데이터 정리 오류: ${r}`)})}a.forEach(r=>{r.postMessage({type:"symbolData",data:i})})},f.onclose=()=>{a.forEach(o=>{o.postMessage("연결 끊김")})}};U.onconnect=e=>{const o=e.ports[0];a.push(o),o.onmessage=s=>{console.log("Received from client:",s.data)},Object.keys(i).length>0&&o.postMessage({type:"symbolData",data:i}),a.forEach(s=>{s.postMessage("유저가 추가됨")}),o.start()};const S=async()=>{await p()?y("wss://stream.binance.us:9443/ws/!ticker@arr"):y()};S();
