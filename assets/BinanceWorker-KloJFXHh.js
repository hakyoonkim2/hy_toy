(function(){"use strict";const f="wss://stream.binance.com:9443/ws/!ticker@arr",a="https://api.binance.com/api/v3";async function p(){try{const o=await(await fetch(`${a}/exchangeInfo`)).json();if(!o.symbols)throw new Error("Failed to fetch symbols list");return o.symbols.filter(e=>e.symbol.endsWith("USDT")&&e.status==="TRADING").map(e=>e.symbol)}catch(r){return console.error("Error fetching symbols list:",r),[]}}async function u(r){const o=`${a}/klines?symbol=${r}&interval=1d&limit=2`;try{const e=await(await fetch(o)).json();if(!Array.isArray(e)||e.length<2)throw new Error(`No sufficient data for ${r}`);const s=e.length>=2?e[1][1]:e[0][1],t=e.length>=2?e[1][4]:e[0][4];return{symbol:r,openPrice:s,curPrice:t}}catch(n){return console.error(`Error fetching data for ${r}:`,n),{symbol:r,openPrice:null,curPrice:null}}}async function y(r){const o=await p();if(o.length===0){console.error("No symbols available.");return}console.log(`Fetching open prices for ${o.length} symbols...`),(await Promise.all(o.map(u))).forEach(e=>{let s="#FFFFFF";const t=parseFloat(e.curPrice),c=parseFloat(e.openPrice);c<t?s="#f75467":c>t&&(s="#4386f9"),r[e.symbol]={price:t,color:s,openPrice:c}})}function h(r,o){r.forEach(n=>{const{symbol:e,price:s,openPrice:t}=b(n);if(o[e]){let c="#FFFFFF";o[e].openPrice<s?c="#f75467":o[e].openPrice>s&&(c="#4386f9"),o[e].price=s,o[e].color=c,t&&(o[e].openPrice=t)}})}function b(r){if("s"in r&&"c"in r)return{symbol:r.s,price:parseFloat(r.c)};if("code"in r&&"trade_price"in r)return{symbol:r.code,price:r.trade_price,openPrice:r.opening_price};throw new Error("Unknown data type")}const i={};let l=null;y(i);const g=()=>{l=new WebSocket(f),l.onmessage=r=>{const o=JSON.parse(r.data),n=Array.from(o).filter(e=>e.s.includes("USDT"));try{h(n,i)}catch{self.postMessage("데이터 정리 오류")}self.postMessage({type:"symbolData",data:i})},l.onclose=()=>{self.postMessage("연결 끊김")}};self.onmessage=()=>{},g()})();
