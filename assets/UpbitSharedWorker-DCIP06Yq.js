(function(){"use strict";const n=[];for(let e=0;e<256;++e)n.push((e+256).toString(16).slice(1));function y(e,t=0){return(n[e[t+0]]+n[e[t+1]]+n[e[t+2]]+n[e[t+3]]+"-"+n[e[t+4]]+n[e[t+5]]+"-"+n[e[t+6]]+n[e[t+7]]+"-"+n[e[t+8]]+n[e[t+9]]+"-"+n[e[t+10]]+n[e[t+11]]+n[e[t+12]]+n[e[t+13]]+n[e[t+14]]+n[e[t+15]]).toLowerCase()}let p;const b=new Uint8Array(16);function g(){if(!p){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");p=crypto.getRandomValues.bind(crypto)}return p(b)}var u={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function h(e,t,r){var c;if(u.randomUUID&&!e)return u.randomUUID();e=e||{};const o=e.random??((c=e.rng)==null?void 0:c.call(e))??g();if(o.length<16)throw new Error("Random bytes length must be >= 16");return o[6]=o[6]&15|64,o[8]=o[8]&63|128,y(o)}async function m(){try{const e=encodeURIComponent("https://api.upbit.com/v1/market/all?isDetails=true"),t=await fetch(`/api/proxy?url=${e}`),r=await t.json();if(t.status!==200)throw new Error("Failed to fetch symbols list");return r.filter(c=>c.market.startsWith("KRW-"))}catch(e){throw e}}async function f(e){const t=await m();if(t.length===0){console.error("No symbols available.");return}console.log(`Fetching open prices for ${t.length} symbols...`),t.forEach(r=>{e[r.market]={price:0,color:"#FFFFFF",openPrice:0}})}function U(e,t){e.forEach(r=>{const{symbol:o,price:c,openPrice:l}=w(r);if(t[o]){let d="#FFFFFF";t[o].openPrice<c?d="#f75467":t[o].openPrice>c&&(d="#4386f9"),t[o].price=c,t[o].color=d,l&&(t[o].openPrice=l)}})}function w(e){if("s"in e&&"c"in e)return{symbol:e.s,price:parseFloat(e.c)};if("code"in e&&"trade_price"in e)return{symbol:e.code,price:e.trade_price,openPrice:e.opening_price};throw new Error("Unknown data type")}const F=self,a=[],i={};let s=null;const k=()=>{s=new WebSocket("wss://api.upbit.com/websocket/v1/ticker"),s.binaryType="arraybuffer",s.onopen=()=>{console.log("Connected"),f(i).then(()=>{const e=[{ticket:h()},{type:"ticker",codes:Object.keys(i)}];s==null||s.send(JSON.stringify(e))}).catch(e=>{a.forEach(t=>{t.postMessage({type:"error upbit 종목 데이터 받아오기",data:e})})})},s.onmessage=e=>{const r=new TextDecoder("utf-8").decode(e.data),o=JSON.parse(r);a.forEach(c=>{c.postMessage({type:"upbit 데이터 정리 시작",data:o})});try{U([o],i)}catch{a.forEach(l=>{l.postMessage("upbit 데이터 정리 오류")})}a.forEach(c=>{c.postMessage({type:"UpbitsymbolData",data:{...i[o.code],symbol:o.code}})})},s.onclose=()=>{a.forEach(e=>{e.postMessage("연결 끊김")})}};F.onconnect=e=>{const t=e.ports[0];a.push(t),t.onmessage=r=>{console.log("Received from client:",r.data)},Object.keys(i).length>0&&t.postMessage({type:"symbolData",data:i}),a.forEach(r=>{r.postMessage("유저가 추가됨")}),t.start()},k()})();
