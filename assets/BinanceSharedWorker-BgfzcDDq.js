let l="";function S(e,o){e.forEach(t=>{const{symbol:n,price:r,openPrice:s}=h(t);if(o[n]){const c=B(o[n].openPrice,r);o[n].price=r,o[n].color=c,s&&(o[n].openPrice=s)}})}function h(e){if("s"in e&&"c"in e)return{symbol:e.s,price:parseFloat(e.c)};if("code"in e&&"trade_price"in e)return{symbol:e.code,price:e.trade_price,openPrice:e.opening_price};throw new Error("Unknown data type")}function B(e,o){let t="#FFFFFF";return e<o?t="#f75467":e>o&&(t="#4386f9"),t}async function p(){if(l.length===0)try{const e=await fetch("https://proxy-server-flax-rho.vercel.app/api/proxy?locale=find"),{country:o}=await e.json();return l=o,o==="US"}catch(e){return console.error("Failed to detect country from IP:",e),!1}else return l==="US"}const _="https://api.binance.com/api/v3",u="https://api.binance.us/api/v3";async function P(){try{const e=await p(),t=await(await fetch(`${e?u:_}/exchangeInfo`)).json();if(!t.symbols)throw new Error("Failed to fetch symbols list");return t.symbols.filter(r=>r.symbol.endsWith("USDT")&&r.status==="TRADING").map(r=>r.symbol)}catch(e){return console.error("Error fetching symbols list:",e),[]}}async function T(e){const t=`${await p()?u:_}/klines?symbol=${e}&interval=1d&limit=2`;try{const r=await(await fetch(t)).json();if(!Array.isArray(r)||r.length<2)throw new Error(`No sufficient data for ${e}`);const s=r.length>=2?r[1][1]:r[0][1],c=r.length>=2?r[1][4]:r[0][4];return{symbol:e,openPrice:s,curPrice:c}}catch(n){return console.error(`Error fetching data for ${e}:`,n),{symbol:e,openPrice:null,curPrice:null}}}async function E(e){const o=await P();if(o.length===0){console.error("No symbols available.");return}console.log(`Fetching open prices for ${o.length} symbols...`),(await Promise.all(o.map(T))).forEach(n=>{let r="#FFFFFF";const s=parseFloat(n.curPrice),c=parseFloat(n.openPrice);c<s?r="#f75467":c>s&&(r="#4386f9"),e[n.symbol]={price:s,color:r,openPrice:c}})}const b="wss://stream.binance.com:9443/ws/",d="wss://stream.binance.us:9443/ws/";var A=(e=>(e.UPBIT_SYMBOL_LIST="UPBIT_SYMBOL_LIST",e.UPBIT_SYMBOL_TRADE_DATA="UPBIT_SYMBOL_TRADE_DATA",e.UPBIT_SYMBOLS_RESTAPI_TRADE_DATA="UPBIT_SYMBOLS_RESTAPI_TRADE_DATA",e.BINANCE_SYMBOLS_DATA="BINANCE_SYMBOLS_DATA",e))(A||{});const g=self,a=[],i={};let f=null;E(i);const y=e=>{f=new WebSocket(e),f.onmessage=o=>{const t=JSON.parse(o.data),n=Array.from(t).filter(r=>r.s.includes("USDT"));try{S(n,i)}catch(r){a.forEach(s=>{s.postMessage(`데이터 정리 오류: ${r}`)})}a.forEach(r=>{r.postMessage({type:A.BINANCE_SYMBOLS_DATA,data:i})})},f.onclose=()=>{a.forEach(o=>{o.postMessage("연결 끊김")})}};g.onconnect=e=>{const o=e.ports[0];a.push(o),o.onmessage=t=>{console.log("Received from client:",t.data)},Object.keys(i).length>0&&o.postMessage({type:A.BINANCE_SYMBOLS_DATA,data:i}),a.forEach(t=>{t.postMessage("유저가 추가됨")}),o.start()};const w=async()=>{const e=await p();y(e?`${d}!ticker@arr`:`${b}!ticker@arr`)};w();
