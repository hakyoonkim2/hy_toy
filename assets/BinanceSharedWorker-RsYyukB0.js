let l="";function T(e,t,r){e.forEach(n=>{const{symbol:o,price:s,openPrice:c}=P(n);if(t[o]){const B=E(t[o].openPrice,s);t[o].price=s,t[o].color=B,c&&(t[o].openPrice=c),r[o]||(r[o]=t[o])}})}function P(e){if("s"in e&&"c"in e)return{symbol:e.s,price:parseFloat(e.c)};if("code"in e&&"trade_price"in e)return{symbol:e.code,price:e.trade_price,openPrice:e.opening_price};throw new Error("Unknown data type")}function E(e,t){let r="#FFFFFF";return e<t?r="#f75467":e>t&&(r="#4386f9"),r}async function A(){if(l.length===0)try{const e=await fetch("https://proxy-server-flax-rho.vercel.app/api/proxy?locale=find"),{country:t}=await e.json();return l=t,t==="US"}catch(e){return console.error("Failed to detect country from IP:",e),!1}else return l==="US"}const S="https://api.binance.com/api/v3",h="https://api.binance.us/api/v3";async function b(){try{const e=await A(),r=await(await fetch(`${e?h:S}/exchangeInfo`)).json();if(!r.symbols)throw new Error("Failed to fetch symbols list");return r.symbols.filter(o=>o.symbol.endsWith("USDT")&&o.status==="TRADING").map(o=>o.symbol)}catch(e){return console.error("Error fetching symbols list:",e),[]}}async function d(e){const r=`${await A()?h:S}/klines?symbol=${e}&interval=1d&limit=2`;try{const o=await(await fetch(r)).json();if(!Array.isArray(o)||o.length<2)throw new Error(`No sufficient data for ${e}`);const s=o.length>=2?o[1][1]:o[0][1],c=o.length>=2?o[1][4]:o[0][4];return{symbol:e,openPrice:s,curPrice:c}}catch(n){return console.error(`Error fetching data for ${e}:`,n),{symbol:e,openPrice:null,curPrice:null}}}async function g(e){const t=await b();if(t.length===0){console.error("No symbols available.");return}console.log(`Fetching open prices for ${t.length} symbols...`),(await Promise.all(t.map(d))).forEach(n=>{let o="#FFFFFF";const s=parseFloat(n.curPrice),c=parseFloat(n.openPrice);c<s?o="#f75467":c>s&&(o="#4386f9"),e[n.symbol]={price:s,color:o,openPrice:c}})}const w="wss://stream.binance.com:9443/ws/",I="wss://stream.binance.us:9443/ws/";var y=(e=>(e.UPBIT_SYMBOL_LIST="UPBIT_SYMBOL_LIST",e.UPBIT_SYMBOL_TRADE_DATA="UPBIT_SYMBOL_TRADE_DATA",e.UPBIT_SYMBOLS_RESTAPI_TRADE_DATA="UPBIT_SYMBOLS_RESTAPI_TRADE_DATA",e.BINANCE_SYMBOLS_DATA="BINANCE_SYMBOLS_DATA",e))(y||{});const U=self,a=[],i={};let f=null,p=null,u={};g(i);const _=e=>{f=new WebSocket(e),f.onmessage=t=>{const r=JSON.parse(t.data),n=Array.from(r).filter(o=>o.s.includes("USDT"));try{T(n,i,u)}catch(o){a.forEach(s=>{s.postMessage(`데이터 정리 오류: ${o}`)})}p||(p=setTimeout(()=>{a.forEach(o=>{o.postMessage({type:y.BINANCE_SYMBOLS_DATA,data:u})}),u={},p=null},300))},f.onclose=()=>{a.forEach(t=>{t.postMessage("연결 끊김")})}};U.onconnect=e=>{const t=e.ports[0];a.push(t),t.onmessage=r=>{console.log("Received from client:",r.data)},Object.keys(i).length>0&&t.postMessage({type:y.BINANCE_SYMBOLS_DATA,data:i}),a.forEach(r=>{r.postMessage("유저가 추가됨")}),t.start()};const N=async()=>{const e=await A();_(e?`${I}!ticker@arr`:`${w}!ticker@arr`)};N();
